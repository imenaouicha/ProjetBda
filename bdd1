-- Création de la base
CREATE DATABASE exams_db;
\c exams_db;

-- Schéma dédié
CREATE SCHEMA planning;
SET search_path TO planning;

-- Table des rôles applicatifs
CREATE TABLE roles (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(50) UNIQUE NOT NULL
);

-- Table des utilisateurs (authentification)
CREATE TABLE utilisateurs (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100) NOT NULL,
    email VARCHAR(120) UNIQUE NOT NULL,
    mot_de_passe VARCHAR(255) NOT NULL,
    role_id INT NOT NULL REFERENCES roles(id),
    actif BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Départements
CREATE TABLE departements (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100) UNIQUE NOT NULL
);

-- Formations
CREATE TABLE formations (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(120) NOT NULL,
    dept_id INT REFERENCES departements(id),
    nb_modules INT CHECK (nb_modules >= 0),
    UNIQUE (nom, dept_id)
);

-- Étudiants
CREATE TABLE etudiants (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    prenom VARCHAR(100),
    formation_id INT REFERENCES formations(id),
    promo VARCHAR(50),
    utilisateur_id INT REFERENCES utilisateurs(id)
);

-- Professeurs
CREATE TABLE professeurs (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(120),
    dept_id INT REFERENCES departements(id),
    specialite VARCHAR(120),
    utilisateur_id INT REFERENCES utilisateurs(id),
    total_surveillance INT DEFAULT 0
);

-- Salles / amphis
CREATE TABLE lieu_examen (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100),
    capacite INT CHECK (capacite > 0),
    type VARCHAR(30) CHECK (type IN ('amphi','salle_td','laboratoire')),
    batiment VARCHAR(80),
    UNIQUE (batiment, nom)
);

-- Modules
CREATE TABLE modules (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(120),
    credits INT CHECK (credits >= 0),
    formation_id INT REFERENCES formations(id),
    pre_req_id INT REFERENCES modules(id)
);

-- Périodes d'examen
CREATE TABLE periodes_examen (
    id SERIAL PRIMARY KEY,
    date DATE NOT NULL,
    heure_debut TIME NOT NULL,
    heure_fin TIME NOT NULL
);

-- Examens
CREATE TABLE examens (
    id SERIAL PRIMARY KEY,
    module_id INT REFERENCES modules(id),
    prof_id INT REFERENCES professeurs(id),
    salle_id INT REFERENCES lieu_examen(id),
    periode_id INT REFERENCES periodes_examen(id),
    type VARCHAR(30) CHECK (type IN ('final', 'rattrapage')),
    duree_minutes INT CHECK (duree_minutes BETWEEN 30 AND 360),
    date_heure TIMESTAMP GENERATED ALWAYS AS (periodes_examen.date + periodes_examen.heure_debut) STORED
);

-- Inscriptions
CREATE TABLE inscriptions (
    etudiant_id INT REFERENCES etudiants(id),
    module_id INT REFERENCES modules(id),
    note NUMERIC(4,2),
    PRIMARY KEY (etudiant_id, module_id)
);

-- Surveillances
CREATE TABLE surveillances (
    id SERIAL PRIMARY KEY,
    examen_id INT REFERENCES examens(id),
    prof_id INT REFERENCES professeurs(id),
    priorite_dept BOOLEAN DEFAULT TRUE
);

-- Disponibilités des professeurs
CREATE TABLE disponibilites (
    id SERIAL PRIMARY KEY,
    prof_id INT REFERENCES professeurs(id),
    periode_id INT REFERENCES periodes_examen(id),
    disponible BOOLEAN DEFAULT TRUE
);

-- Index pour optimiser les requêtes
CREATE INDEX idx_exam_module ON examens(module_id);
CREATE INDEX idx_exam_prof ON examens(prof_id);
CREATE INDEX idx_exam_salle ON examens(salle_id);
CREATE INDEX idx_exam_periode ON examens(periode_id);

-- Trigger pour compter les surveillances
CREATE OR REPLACE FUNCTION update_surveillance_count()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE professeurs
    SET total_surveillance = total_surveillance + 1
    WHERE id = NEW.prof_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_surveillance
AFTER INSERT ON surveillances
FOR EACH ROW EXECUTE FUNCTION update_surveillance_count();

-- Trigger pour vérifier la capacité des salles
CREATE OR REPLACE FUNCTION check_salle_capacity()
RETURNS TRIGGER AS $$
DECLARE
    nb_etudiants INT;
BEGIN
    SELECT COUNT(*) INTO nb_etudiants
    FROM inscriptions i
    JOIN examens e ON i.module_id = e.module_id
    WHERE e.salle_id = NEW.salle_id AND e.periode_id = NEW.periode_id;
    
    IF nb_etudiants > (SELECT capacite FROM lieu_examen WHERE id = NEW.salle_id) THEN
        RAISE EXCEPTION 'Salle surchargée';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_check_salle_capacity
BEFORE INSERT OR UPDATE ON examens
FOR EACH ROW EXECUTE FUNCTION check_salle_capacity();
